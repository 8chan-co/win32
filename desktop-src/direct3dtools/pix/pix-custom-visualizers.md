---
title: Custom texture/mesh visualizers
description: Documenting how to use custom texture/mesh visualizers with PIX
ms.topic: article
ms.date: 07/30/2024
---

# Custom Texture/Mesh Visualizers

Custom visualizers allow you to do mainly two things: 

1. Extend the pipeline view texture viewer to run a custom compute shader which can read any resource bound to any stage of the pipeline and output a 2D texture displayed in the viewer. 

2. Extend the pipeline view buffer viewer to run a custom compute shader which can read any resource bound to any stage of the pipeline and output both an index buffer and a vertex buffer to be displayed in the mesh viewer. 

## PIX Extensibility Settings 

You can specify any number of folders for PIX to search for visualizers (*.hlsl files) in the *Extensibility Paths* setting. 

If your visualizer shaders use any ```#include``` of files not sitting next to the main HLSL visualizer files, you can specify search paths to those in the *Extensibility Include Search Paths* setting. 

![Where to modify the extensions paths in PIX](images/custom-visualizers-paths.png)

## Custom Texture Visualizer 

Assuming you have setup paths to your visualizer shaders in the settings, you can now see your visualizers listed in the Visualization panel. 

![Example of some visualizers in the dropdown menu](images/custom-visualizers-dropdown.png)

### Visualization Panel 

Once you have selected a custom visualizer from the list in the Visualization panel, the *Custom Visualization* section appears. From there, you can select to override the default texture format for your visualizer output. By default, the selected output format will be compatible with the pipeline view currently selected texture. That's also where any shader compilation warnings/errors will be displayed. 

![Example of a custom extension compiler error](images/custom-visualizers-compiler-error.png)

### Creating a Custom Texture Visualizer 

A visualizer is a compute shader running against the selected event (i.e. draw, dispatch, dispatch mesh) and which output will be displayed in the texture viewer in place of the currently selected texture / render target. Your entry point must be named main to be successfully recognized by PIX. 

You can select the thread group size of your compute shader as you do with any compute shader by specifying it as an attribute (e.g. ```[numthreads(8, 8, 1)]```). PIX will invoke your compute shader so one thread can execute per pixel.  

For instance, if you have a texture of size 512x512 pixels and your compute shader uses a threadgroup size of (8, 8, 1), the resulting invocation done internally by the PIX engine would be ```Dispatch(64, 64, 1)```. If the texture size is not a multiple of the threadgroup size, more threads than pixels are invoked to cover all of them. 

The output texture generated by your compute shader will reflect the largest coordinates it outputs through the HLSL API (e.g. ```PixExt_StorePixel_Float(uint2 offset, float4 pixel)```). 

When your shader code is compiled in the PIX engine, the root signature used is a modified version of the one bound at the selected event. That means you get access to all resources as they are available to that event plus all resources bound to the IA and OM stages through the PIX HLSL API. 

If you have errors in your shader (displayed in the *Visualization* panel, *Custom Visualization* section in the *DXC Output* text box), you can simply edit the file to correct the errors and hit the refresh button in the texture viewer to rebuild and re-execute your visualizer.

#### Example

Let's see a basic example of a visualizer shader. 

```
Texture2D<float4> SelectedTexture : PixExt_SelectedResourceRegister;
Texture2D<float4> SRV0 : register(t0);

[numthreads(8, 8, 1)]
void main(PixExt_ComputeInput input)
{
    uint2 selSize, srvSize;
    SelectedTexture.GetDimensions(selSize.x, selSize.y);
    SRV0.GetDimensions(srvSize.x, srvSize.y);

    float2 uvs = input.dispatchThreadId.xy / (float2)selSize;
    int2 srvCoords = (int2)(srvSize * uvs);
	
    float4 selectedValue = SelectedTexture.Load(int3(input.dispatchThreadId.xy, 0));
    float4 srv0Value = SRV0.Load(int3(srvCoords, 0)); 
    float4 finalValue = selectedValue * srv0Value.yzxw;

    PixExt_StorePixel_Float(input.dispatchThreadId.xy, finalValue);
}
```

In this example, we declare ```SelectedTexture``` to point to the pipeline view currently selected texture using the PIX HLSL API special register ```PixExt_SelectedResourceRegister```. We also declare SRV0 at t0, knowing it will be present in the root signature of the GPU capture we're working against. You can always make your extension as generic or specific as your use case dictates. Finally, we output to the texture viewer using the ```PixExt_StorePixel_Float``` function, which takes a pixel position and a value as arguments. 

To get more information on the API, refer to the HLSL API section. 

![Example output from the texture visualizer above](images/custom-visualizers-compiler-texture-example.png)

## Custom Buffer Visualizer 

Assuming you have setup paths to your visualizer shaders in the settings, you can now see your visualizers listed in the *Custom Visualization* panel, which you can open using the following buffer viewer toolbar icon: {} 

### Custom Visualization Panel 

From that panel, you can select any available custom visualizer and see any warning/error messages from the shader compiler. 

![Example error from a buffer visualizer](images/custom-visualizers-buffer-error.png)

### Creating a Custom Buffer Visualizer 

A visualizer is a compute shader running against the selected event and which output will be displayed in the mesh viewer in place of the buffer viewer showing the currently selected buffer data. Your entry point must be named ```main``` to be successfully recognized by PIX. 

You can select the thread group size of your compute shader as you do for any compute shader by specifying it as an attribute (e.g. ```[numthreads(32, 1, 1)]```). PIX will invoke your compute shader so one thread can execute per buffer element. 

For instance, if you have a buffer of 100 elements and your compute shader uses a threadgroup size of (32, 1, 1), the resulting invocation done internally by the PIX engine would be ```Dispatch(4, 1, 1)```. If the buffer size is not a multiple of the threadgroup size, more threads than buffer elements are invoked to cover all of them. 

The output index and vertex buffers allocated to your compute shader are dynamically growing to fit all the data you output. You can output as much data as you need. Indices are 32-bit and vertices are only allowed to be float4 positions. 

When your shader code is compiled in the PIX engine, the root signature used is a modified version of the one bound at the selected event. That means you get access to all resources as they are available to that event plus all resources bound to the IA and OM stages through the PIX HLSL API. 

If you have errors in your shader (displayed in the *Custom Visualization* panel, in the *DXC Output* text box), you can simply edit the file to correct the errors and hit the refresh button  in the mesh viewer to rebuild and re-execute your visualizer.

#### Example

Let's see a basic example of a visualizer shader. 

```
struct Vertex
{
    float3 position;
    float2 uv;
};

StructuredBuffer<Vertex> Vertices : PixExt_VertexBufferRegister0;

[numthreads(32, 1, 1)]
void main(PixExt_ComputeInput input)
{
    const uint vertexCount = PixExt_GetVertexCountPerInstance();

    if (input.dispatchThreadId.x < vertexCount)
    {
        const uint vertexStart = PixExt_GetStartVertexLocation();

        uint vertexOffset = input.dispatchThreadId.x + vertexStart;
        Vertex vertex = Vertices[vertexOffset];
        float4 newPosition = float4(vertex.position, 1.f);
        PixExt_StoreIndex(input.dispatchThreadId.x, input.dispatchThreadId.x);
        PixExt_StoreVertex(input.dispatchThreadId.x, newPosition);
    }
}
```

In this example, we access vertices declaring ```Vertices``` to point to the pipeline view currently bound vertex buffer 0 using the PIX HLSL API special register ```PixExt_VertexBufferRegister0```. We then output to the mesh viewer using the ```PixExt_StoreIndex``` and ```PixExt_StoreVertex``` functions, which take buffer offsets and respectively index and vertex values as arguments. 

To get more information on the API, refer to the HLSL API section. 

![Example output from the buffer visualizer above](images/custom-visualizers-buffer-example.png)

## PIX HLSL API 

PIX will inject internal implementation code when compiling your shader to give you access to all resources and have a standard mean of outputting data to the viewers. The implementation is always subject to change, but the following documented API is stable across PIX versions.

### Resource Access 

The API defines a set of special registers you can use to get access to resources of different pipeline stages that are not inherently accessible. 

#### Selected Resource 

```PixExt_SelectedResourceRegister```: Gives access to the resource currently selected in the pipeline view. 

#### Render Targets 

```PixExt_RenderTargetRegister0```<br>
```PixExt_RenderTargetRegister1```<br>
```PixExt_RenderTargetRegister2```<br>
```PixExt_RenderTargetRegister3```<br>
```PixExt_RenderTargetRegister4```<br>
```PixExt_RenderTargetRegister5```<br>
```PixExt_RenderTargetRegister6```<br>
```PixExt_RenderTargetRegister7```

#### Depth / Stencil 

```PixExt_DepthRegister```<br>
```PixExt_StencilRegister```

#### Input Assembly Stage Resources 

```PixExt_IndexBufferRegister```<br>
```PixExt_VertexBufferRegister0```<br>
```PixExt_VertexBufferRegister1```<br>
```PixExt_VertexBufferRegister2```<br>
```PixExt_VertexBufferRegister3```<br>
```PixExt_VertexBufferRegister4```<br>
```PixExt_VertexBufferRegister5```<br>
```PixExt_VertexBufferRegister6```<br>
```PixExt_VertexBufferRegister7```<br>
```PixExt_VertexBufferRegister8```<br>
```PixExt_VertexBufferRegister9```<br>
```PixExt_VertexBufferRegister10```<br>
```PixExt_VertexBufferRegister11```<br>
```PixExt_VertexBufferRegister12```<br>
```PixExt_VertexBufferRegister13```<br>
```PixExt_VertexBufferRegister14```<br>
```PixExt_VertexBufferRegister15```<br>
```PixExt_VertexBufferRegister16```<br>
```PixExt_VertexBufferRegister17```<br>
```PixExt_VertexBufferRegister18```<br>
```PixExt_VertexBufferRegister19```<br>
```PixExt_VertexBufferRegister20```<br>
```PixExt_VertexBufferRegister21```<br>
```PixExt_VertexBufferRegister22```<br>
```PixExt_VertexBufferRegister23```<br>
```PixExt_VertexBufferRegister24```<br>
```PixExt_VertexBufferRegister25```<br>
```PixExt_VertexBufferRegister26```<br>
```PixExt_VertexBufferRegister27```<br>
```PixExt_VertexBufferRegister28```<br>
```PixExt_VertexBufferRegister29```<br>
```PixExt_VertexBufferRegister30```<br>
```PixExt_VertexBufferRegister31```<br>

#### Shader Inputs 

You can use the ```PixExt_ComputeInput``` structure as an input to your main shader function. This is a helper and is not mandatory. 

```
struct PixExt_ComputeInput
{
    uint3 dispatchThreadId : SV_DispatchThreadID;
    uint3 groupId : SV_GroupID;
    uint3 groupThreadId : SV_GroupThreadID;
    uint groupIndex : SV_GroupIndex;
};
```

#### Selected texture Information 

```
// Returns the currently selected sample.
uint PixExt_GetSelectedSample();

// Returns the currently selected mip.
uint PixExt_GetSelectedMip();

// Returns the currently selected slice.
uint PixExt_GetSelectedSlice();
```

#### Selected Event Arguments 

```
// For a DrawIndexedInstanced event,
// returns the IndexCountPerInstance.
uint PixExt_GetIndexCountPerInstance();

// For a DrawIndexedInstanced event,
// returns the StartIndexLocation
uint PixExt_GetStartIndexLocation();

// For a DrawInstanced event,
// returns the VertexCountPerInstance.
uint PixExt_GetVertexCountPerInstance();

// For a DrawInstanced event,
// returns the StartVertexLocation.
uint PixExt_GetStartVertexLocation();

// For a DrawInstanced or DrawIndexedInstanced event,
// returns the InstanceCount.
uint PixExt_GetInstanceCount();

// For a DrawInstanced or DrawIndexedInstanced event,
// returns the StartInstanceLocation.
uint PixExt_GetStartInstanceLocation();

// For a Dispatch or DispatchMesh event,
// returns the ThreadGroupCountX.
uint PixExt_GetThreadGroupCountX();

// For a Dispatch or DispatchMesh event,
// returns the ThreadGroupCountY.
uint PixExt_GetThreadGroupCountY();

// For a Dispatch or DispatchMesh event,
// returns the ThreadGroupCountZ.
uint PixExt_GetThreadGroupCountZ();
```

#### Shader Outputs 

You output data to the viewers using the following functions. 

##### Texture

```
// Stores the given INT pixel data for texture viewer display.
//
// offset: Pixel position to write to.
// pixel: Pixel data to write.
void PixExt_StorePixel_Int(uint2 offset, int4 pixel);

// Stores the given UINT pixel data for texture viewer display.
//
// offset: Pixel position to write to.
// pixel: Pixel data to write.
void PixExt_StorePixel_Uint(uint2 offset, uint4 pixel);

// Stores the given FLOAT pixel data for texture viewer display.
//
// offset: Pixel position to write to.
// pixel: Pixel data to write.
void PixExt_StorePixel_Float(uint2 offset, float4 pixel);
```

##### Mesh
```
// Stores the given index for mesh viewer display.
//
// offset: Offset into the index buffer to write to.
// index: Index to write.
void PixExt_StoreIndex(uint offset, uint index);

// Stores the given vertex position for mesh viewer display.
//
// offset: Offset into the vertex buffer to write to.
// vertex: Vertex position to write.
void PixExt_StoreVertex(uint offset, float4 vertex);
```